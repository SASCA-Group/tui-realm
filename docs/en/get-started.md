# Get Started 🏁

- [Get Started 🏁](#get-started-)
  - [An introduction to realm](#an-introduction-to-realm)
  - [Key Concepts](#key-concepts)
  - [MockComponent Vs. Component](#mockcomponent-vs-component)
  - [Application, Model and View](#application-model-and-view)
    - [Focus](#focus)
  - [Event -> (Cmd -> CmdResult) -> Msg](#event---cmd---cmdresult---msg)
  - [Lifecycle (or a "tick")](#lifecycle-or-a-tick)
  - [Our first application](#our-first-application)
  - [What's next](#whats-next)

---

## An introduction to realm

TODO: youtube link

tui-realm is a tui-rs **framework** which provides an easy way to implement stateful application.
First of all, let's give a look to the main features of tui-realm and why you should opt for this framework when building
terminal user interfaces:

- ⌨️ **Event-driven**

    tui-realm uses the `Event -> Msg` approach, taken from Elm. **Events** are produced by some entities called `Port`, which work as event listener (such as a stdin reader or an HTTP client), which produce Events. These are then forwarded to **Components**, which will produce a **Message**. The message will cause then a certain behaviour on your application model, based on its variant.
    Kinda simple and everything in your application will work around this logic, so it's really easy to implement whatever you want.

- ⚛️ Based on **React** and **Elm**

    tui-realm is based on [React] and [Elm](https://elm-lang.org/). These two are kinda different as approach, but I decided to take the best from each of them to combine them in **Realm**. From React I took the **Component** concept. In realm each component represents a single graphic instance, which could potentially include some children; each component then has a **State** and some **Properties**.
    From Elm I basically took every other concept implemented in Realm. I really like Elm as a language, in particular the **TEA**.
    Indeed, as in Elm, in realm the lifecycle of the application is `Event -> Msg -> Update -> View -> Event -> ...`

- 🍲 **Boilerplate** code

    tui-realm may look hard to work with at the beginning, but after a while you'll be start realizing how the code you're implementing is just boilerplate code you're copying from your previous components.

- 🚀 Quick-setup

    Since the newest tui-realm API (1.x) tui-realm has become really easy to learn and to setup, thanks to the new `Application` data type, event listeners and to the `Terminal` helper.

- 🎯 Single **focus** and **states** management

    Instead of managing focus and states by yourself, in realm everything is automatically managed by the **View**, which is where all components are mounted. With realm you don't have to worry about the application states and focus anymore.

- 🙂 Easy to learn

    Thanks to the few data types exposed to the user and to the guides, it's really easy to learn tui-realm, even if you've never worked with tui or Elm before.

- 🤖 Adaptable to any use case

    As you will learn through this guide, tui-realm exposes some advanced concepts to create your own event listener, to work with your own event and to implement complex components.

---

## Key Concepts

Let's see now what are the key concepts of tui-realm. In the introduction you've probably read about some of them in **bold**, but let's see them in details now. Key concepts are really important to understand, luckily they're easy to understand and there aren't many of them:

- **MockComponent**:
- **Component**:
- **State**:
- **Attribute**:
- **Event**: an event is a **raw** entity describing an event caused mainly but the user (such as a keystroke), but could also be generated by an external source (we're going to talk about these last in the "advanced concepts").
- **Message** (or usually called `Msg`): A message is a Logic event that is generated from the Components, after an **Event**.

    While the Event is *raw* (such as a keystroke), the message is application-oriented. The message is later consumed by the **Update routine**. I think an example would explain it better: let's say we have a popup component, that when `ESC` is pressed, it must report to the application to hide it. Then the event will be `Key::Esc`, it will consume it, and will return a `PopupClose` message. The mesage are totally user-defined through template types, but we'll see that later in this guide.

- **View**
- **Model**
- **Subscription**
- **Port**
- **Application**
- **Update routine**:
- **Tick**

---

## MockComponent Vs. Component

---

## Application, Model and View

### Focus

---

## Event -> (Cmd -> CmdResult) -> Msg

---

## Lifecycle (or a "tick")

---

## Our first application

---

## What's next

You now might be interested in read more about the tui-realm, so you may be interested in these reads:

- [Advanced concepts](advanced.md)
- [Migrating tui-realm 0.x to 1.x](migrating-legacy.md)
- [Implementing new components](new-components.md)
